package org.deadmandungeons.deadmanplugin.filedata;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.logging.Level;

import org.bukkit.Bukkit;
import org.bukkit.configuration.ConfigurationOptions;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.InvalidConfigurationException;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.configuration.file.YamlConfigurationOptions;
import org.deadmandungeons.deadmanplugin.DeadmanPlugin;

/**
 * This class is used to represent a YAML file for a DeadmanPlugin which can be easily loaded and saved.
 * @see {@link PluginFile#creator(DeadmanPlugin, String)}
 * @author Jon
 */
public class PluginFile {
	
	private static final String WARNING_MSG = "\n %1$s %2$s file\n\n WARNING: THIS FILE IS AUTOMATICALLY GENERATED."
			+ " If you modify this file by\n hand, be aware that A SINGLE MISTYPED CHARACTER CAN CORRUPT THE FILE. If\n "
			+ "%1$s is unable to parse the file, the plugin may BREAK!\n\n REMEMBER TO KEEP PERIODICAL BACKUPS.\n ";
	private static final String MISSING_RESOURCE_MSG = "The embedded resource '%s' could not be found in this pluigin";
	private static final int MIN_AUTO_SAVE_FREQUENCY = 10; // seconds
	
	private final DeadmanPlugin plugin;
	private final String filePath;
	private final File file;
	
	private final String defaultFilePath;
	private final Character pathSeparator;
	private final Integer indent;
	private final String header;
	private final int autoSaveFrequency;
	
	private FileConfiguration fileConfig;
	private int reloadCount;
	private boolean dirty;
	
	
	/**
	 * @param plugin - The DeadmanPlugin instance the created PluginFile belongs to
	 * @param filePath - The path to the PluginFile relative to the plugin's directory.
	 * If a file at this path does not exist, a new file will be created.
	 * @return a new Creator object to further define the PluginFile details and ultimately create the PluginFile
	 */
	public static Creator creator(DeadmanPlugin plugin, String filePath) {
		return new Creator(plugin, filePath);
	}
	
	/**
	 * This class acts as a PluginFile builder to enable PluginFile options
	 * @author Jon
	 */
	public static class Creator {
		
		private final DeadmanPlugin plugin;
		private final String filePath;
		
		private String defaultFilePath;
		private Character pathSeparator;
		private Integer indent;
		private int autoSaveFrequency;
		
		private Creator(DeadmanPlugin plugin, String filePath) {
			if (plugin == null) {
				throw new IllegalArgumentException("plugin cannot be null");
			}
			if (filePath == null) {
				throw new IllegalArgumentException("filePath cannot be null");
			}
			this.plugin = plugin;
			this.filePath = filePath;
		}
		
		/**
		 * @param defaultFilePath - the path to the embedded file in this plugin's jar containing the default configuration
		 * @return this Creator instance
		 * @throws IllegalArgumentException if defaultFilePath is blank (whitespace or empty)
		 */
		public Creator defaultFile(String defaultFilePath) throws IllegalArgumentException {
			if (defaultFilePath != null && defaultFilePath.trim().isEmpty()) {
				throw new IllegalArgumentException("defaultFilePath cannot be empty");
			}
			this.defaultFilePath = defaultFilePath;
			return this;
		}
		
		/**
		 * @see {@link ConfigurationOptions#pathSeparator(char)}
		 * @param pathSeparator - the char that will be used to separate {@link ConfigurationSection}s
		 * @return this Creator instance
		 */
		public Creator pathSeparator(char pathSeparator) {
			this.pathSeparator = pathSeparator;
			return this;
		}
		
		/**
		 * @see {@link YamlConfigurationOptions#indent(int)}
		 * @param indent - the amount of spaces that should be used to indent each line
		 * @return this Creator instance
		 * @throws IllegalArgumentException if indent is less than 2 or greater than 9
		 */
		public Creator indent(int indent) throws IllegalArgumentException {
			if (indent < 2 || indent > 9) {
				throw new IllegalArgumentException("indent cannot be less than 2 or greater than 9");
			}
			this.indent = indent;
			return this;
		}
		
		/**
		 * A BukkitScheduler repeating timer will be started with a delay and time period equal to the given amount in seconds.
		 * This is useful if data stored in the created PluginFile is updated frequently and when it is not important that recently
		 * updated unsaved data is guaranteed to be persisted when reloaded. This is because if the state of the PluginFile is
		 * dirty (unsaved data), and {@link PluginFile#reloadConfig()} is called (or if the plugin is disabled), the reloaded
		 * data would overwrite any previously unsaved data.
		 * @param seconds - the frequency of auto-save checks in seconds
		 * @return this Creator instance
		 * @throws IllegalArgumentException if seconds is less than 10 because any more frequent would start to
		 * defeat the purpose of auto-save
		 */
		public Creator autoSaveEvery(int seconds) throws IllegalArgumentException {
			if (seconds < MIN_AUTO_SAVE_FREQUENCY) {
				throw new IllegalArgumentException("seconds cannot be less than " + MIN_AUTO_SAVE_FREQUENCY);
			}
			this.autoSaveFrequency = seconds;
			return this;
		}
		
		/**
		 * @return a new PluginFile instance with the details set in this Creator
		 * @throws IllegalArgumentException if an embedded resource does not exist at the defaultFilePath (if one was specified)
		 * @throws PluginFileException if the PluginFile failed to be created (if it did not exist), or if it failed to be loaded
		 */
		public PluginFile create() throws IllegalArgumentException, PluginFileException {
			return new PluginFile(this);
		}
		
	}
	
	private PluginFile(Creator creator) throws IllegalArgumentException, PluginFileException {
		if (!creator.plugin.isLoaded()) {
			throw new IllegalStateException("This plugin has not been loaded yet! Cannot create plugin file before plugin is loaded");
		}
		this.plugin = creator.plugin;
		this.filePath = plugin.getDataFolder().getPath() + File.separator + creator.filePath;
		this.file = new File(filePath);
		
		this.defaultFilePath = (creator.defaultFilePath != null ? creator.defaultFilePath.replace('\\', '/') : null);
		this.pathSeparator = creator.pathSeparator;
		this.indent = creator.indent;
		this.header = String.format(WARNING_MSG, plugin.getName(), file.getName());
		
		if (defaultFilePath != null && plugin.getClass().getClassLoader().getResource(defaultFilePath) == null) {
			throw new IllegalArgumentException(String.format(MISSING_RESOURCE_MSG, defaultFilePath));
		}
		
		// create the file if it doesn't exist either as copy of an embedded file or as a new file
		boolean isNewFile = false;
		if (!file.exists()) {
			if (file.getParentFile() != null) {
				file.getParentFile().mkdirs();
			}
			
			if (defaultFilePath != null) {
				try {
					plugin.getLogger().info("Saving default '" + defaultFilePath + "' PluginFile as '" + filePath + "'");
					
					saveResource(defaultFilePath, file);
				} catch (IOException e) {
					throw new PluginFileException("Could not save '" + defaultFilePath + "' to '" + file + "'", e);
				}
			} else {
				try {
					plugin.getLogger().info("Creating file " + filePath);
					
					file.createNewFile();
					isNewFile = true;
				} catch (IOException e) {
					throw new PluginFileException("Could not create " + file, e);
				}
			}
		}
		
		// load file and save it if the file is new (so the header is set)
		try {
			fileConfig = loadConfig();
		} catch (IOException | InvalidConfigurationException e) {
			throw new PluginFileException("Could not load " + file, e);
		}
		if (isNewFile) {
			try {
				fileConfig.save(file);
			} catch (IOException e) {
				throw new PluginFileException("Could not save " + file, e);
			}
		}
		
		// File creation/loading has succeeded so start auto-save scheduler if autoSaveFrequency was specified
		this.autoSaveFrequency = creator.autoSaveFrequency;
		if (autoSaveFrequency >= MIN_AUTO_SAVE_FREQUENCY) {
			int ticks = autoSaveFrequency * 20;
			Bukkit.getScheduler().runTaskTimer(plugin, new Runnable() {
				
				@Override
				public void run() {
					if (dirty) {
						saveConfig();
					}
				}
			}, ticks, ticks);
		}
	}
	
	
	/**
	 * reload the contents of this PluginFile to its {@link FileConfiguration}, and if this PluginFile
	 * has a default resource, set the FileConfiguration defaults to the loaded YamlConfiguration of the default resource.
	 * @return <code>true</code> if the FileConfiguration for this PluginFile and its defaults were reloaded successfully. <code>false</code>
	 * otherwise.
	 */
	public boolean reloadConfig() {
		try {
			this.fileConfig = loadConfig();
			reloadCount++;
			dirty = false;
			return true;
		} catch (IOException | InvalidConfigurationException e) {
			plugin.getLogger().log(Level.SEVERE, "Failed to load " + file, e);
			return false;
		}
	}
	
	/**
	 * @return The {@link FileConfiguration} for this PluginFile
	 */
	public FileConfiguration getConfig() {
		// This will never be null
		return fileConfig;
	}
	
	/**
	 * Save the {@link FileConfiguration} of this PluginFile to disk.
	 * @return true if the file was successfully saved and false if an IOException occurred
	 */
	public boolean saveConfig() {
		try {
			plugin.getLogger().info("Save file: " + file.getName());
			getConfig().save(file);
			dirty = false;
			return true;
		} catch (IOException ex) {
			plugin.getLogger().log(Level.SEVERE, "Could not save config to " + file, ex);
			return false;
		}
	}
	
	/**
	 * Flag this PluginFile as having a dirty state and that the auto-saver task should save the FileConfiguration to file.
	 * @throws IllegalStateException if auto-save functionality was not enabled for this PluginFile which can be checked
	 * Programmatically by checking if {@link #getAutoSaveFrequency()} is greater than 0.
	 */
	public void setDirty() throws IllegalStateException {
		if (autoSaveFrequency == 0) {
			throw new IllegalStateException("auto-save functionality was not enabled for this PluginFile");
		}
		if (!dirty) {
			dirty = true;
		}
	}
	
	/**
	 * 0 will be returned if an autoSaveFrequency was not specified in the {@link PluginFile#Creator} that created this PluginFile,
	 * and thus auto-save is not enabled.
	 * @return the frequency in seconds of auto-save checks this PluginFile makes which will not be less than 10 if auto-save is enabled.
	 */
	public int getAutoSaveFrequency() {
		return autoSaveFrequency;
	}
	
	/**
	 * This is useful to check if the PluginFile has been reloaded and that any cached values may not be valid.
	 * @return the amount of times this PluginFile has been successfully reloaded.
	 */
	public int getReloadCount() {
		return reloadCount;
	}
	
	
	private YamlConfiguration loadConfig() throws IOException, InvalidConfigurationException {
		YamlConfiguration fileConfig = createYamlConfiguration();
		if (defaultFilePath != null) {
			// Look for defaults in the jar
			InputStream defConfigStream = plugin.getResource(defaultFilePath);
			if (defConfigStream == null) {
				// This shoudln't happen because we validate that the default resource exists in constructor
				throw new IllegalStateException(String.format(MISSING_RESOURCE_MSG, defaultFilePath));
			}
			
			YamlConfiguration defaultConfig = createYamlConfiguration();
			defaultConfig.load(new InputStreamReader(defConfigStream));
			fileConfig.setDefaults(defaultConfig);
		}
		fileConfig.load(file);
		return fileConfig;
	}
	
	private void saveResource(String resourcePath, File outFile) throws IOException {
		if (outFile.exists()) {
			return;
		}
		
		InputStream resource = plugin.getResource(resourcePath);
		if (resource == null) {
			// This shoudln't happen because we validate that the default resource exists in constructor
			throw new IllegalArgumentException(String.format(MISSING_RESOURCE_MSG, resourcePath));
		}
		
		if (outFile.getParentFile() != null && !outFile.getParentFile().exists()) {
			outFile.getParentFile().mkdirs();
		}
		
		try (InputStream in = resource; OutputStream out = new FileOutputStream(outFile)) {
			byte[] buf = new byte[1024];
			int len;
			while ((len = in.read(buf)) > 0) {
				out.write(buf, 0, len);
			}
		}
	}
	
	private YamlConfiguration createYamlConfiguration() {
		YamlConfiguration yaml = new YamlConfiguration();
		yaml.options().header(header);
		if (pathSeparator != null) {
			yaml.options().pathSeparator(pathSeparator);
		}
		if (indent != null) {
			yaml.options().indent(indent);
		}
		return yaml;
	}
	
	
	/**
	 * This exception indicates that a PluginFile failed to create, load, or save the underlying file due to unexpected problems
	 */
	public static class PluginFileException extends RuntimeException {
		
		private static final long serialVersionUID = -7318715464949250756L;
		
		public PluginFileException(String message, Throwable cause) {
			super(message, cause);
		}
		
	}
	
}
